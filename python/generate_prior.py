'''
This script generates netcdfs of the absolute and relative prior emissions and error variances for use in an analytical inversion.

   **Inputs**

   | ----------------- | -------------------------------------------------- |
   | Input             | Description                                        |
   | ----------------- | -------------------------------------------------- |
   | emis_file         | A file or files containing information on methane  |
   |                   | emissions from the prior run. This is typically    |
   |                   | given by HEMCO_diagnostics. The input here can be  |
   |                   | either a list of monthly files or a single file    |
   |                   | with an annual average.                            |
   | ----------------- | -------------------------------------------------- |
   | clusters          | The cluster file generated by generate_clusters.py |
   |                   | that maps a unique key for every grid cell         |
   |                   | contained in the state vector to the latitude-     |
   |                   |longitude grid used in the forward model.           |
   | ----------------- | -------------------------------------------------- |
   | rel_err           | The relative error (standard deviation) value to   |
   |                   | be used in the relative prior error covariance     |
   |                   | matrix. The default is 0.5.                        |
   | ----------------- | -------------------------------------------------- |

   **Outputs**

   | ----------------- | -------------------------------------------------- |
   | Output            | Description                                        |
   | ----------------- | -------------------------------------------------- |
   | xa.nc             | A netcdf containing the relative prior (all ones)  |
   |                   | xa for use in the inversion.                       |
   | ----------------- | -------------------------------------------------- |
   | sa.nc             | A netcdf containing the relative prior error (all  |
   |                   | given by rel_err) for use in the inversion.        |
   | ----------------- | -------------------------------------------------- |
   | xa_abs.nc         | A netcdf containing the absolute prior (all ones)  |
   |                   | xa for use in the inversion.                       |
   | ----------------- | -------------------------------------------------- |
   | sa_abs.nc         | A netcdf containing the absolute prior error (all  |
   |                   | given by rel_err) for use in the inversion.        |
   | ----------------- | -------------------------------------------------- |
'''

from os.path import join
import sys
from copy import deepcopy as dc

import math
import numpy as np
import pandas as pd
import xarray as xr

import matplotlib.pyplot as plt

# Custom packages
sys.path.append('.')
import config
# config.SCALE = config.PRES_SCALE
# config.BASE_WIDTH = config.PRES_WIDTH
# config.BASE_HEIGHT = config.PRES_HEIGHT
import gcpy as gc
import troppy as tp
import invpy as ip
import format_plots as fp
import inversion_settings as s

## ------------------------------------------------------------------------ ##
## Set user preferences
## ------------------------------------------------------------------------ ##
base_dir = '/Users/hannahnesser/Documents/Harvard/Research/TROPOMI_Inversion/'
code_dir = base_dir + 'python'
data_dir = base_dir + 'inversion_data'
plot_dir = base_dir + 'plots'

# The emissions can either be a list of files or a single file
# with an annual average
emis_file = [f'{data_dir}/prior/total_emissions/\
HEMCO_diagnostics.{s.year:04d}{mm:02d}010000.nc'
             for mm in s.months]
# emis_file = f'{data_dir}/prior/total_emissions/HEMCO_diagnostics.{s.year}.nc'
emis_hr_file = [f'{data_dir}/prior/total_emissions/\
HEMCO_sectoral_diagnostics.{s.year:04d}{mm:02d}010000.nc'
             for mm in s.months]
clusters = f'{data_dir}/clusters.nc'
clusters = xr.open_dataarray(clusters)
nstate = int(clusters.max().values)
print(f'n = {nstate}')

# Set relative prior error covariance value
rel_err = 1

# Length of months
days = xr.DataArray([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                    dims='time')

# Sectoral breakdown
emissions = {'wetlands' : 'Wetlands',
             'livestock' : 'Livestock',
             'coal' : 'Coal',
             'ong' : ['Oil', 'Gas'],
             # 'gas' : 'Gas',
             'landfills' : 'Landfills',
             'wastewater' : 'Wastewater',
             'other_anth' : ['Rice', 'OtherAnth'],
             'other_bio' : ['Termites', 'Seeps', 'BiomassBurn', 'Lakes']}

emissions_hr = {'enteric_fermentation' : 'LIVESTOCK_4A',
                'manure_management' : 'LIVESTOCK_4B',
                'coal_abandoned' : 'COAL_ABANDONED',
                'coal_surface' : 'COAL_SURFACE',
                'coal_underground' : 'COAL_UNDERGROUND',
                'oil' : 'OIL',
                'gas_distribution' : 'GAS_DISTRIBUTION',
                'gas_upstream' : ['GAS_TRANSMISSION', 'GAS_PROCESSING', 
                                  'GAS_PRODUCTION'],
                'landfills' : ['LANDFILLS_IND', 'LANDFILLS_MUN'],
                'wastewater' : ['WASTEWATER_IND', 'WASTEWATER_DOM'],
                'other_anth' : ['OTHERANTH_1A_M', 'OTHERANTH_1A_S',
                                'OTHERANTH_2B5', 'OTHERANTH_2C2', 
                                'OTHERANTH_4F', 'OTHERANTH_5',
                                'OTHERANTH_6D']}

## ------------------------------------------------------------------------ ##
## Figure out what the relative prior errors should be set at
## ------------------------------------------------------------------------ ##
def alpha(a0, ka, an, L, L0=0.1):
    return a0*np.exp(-ka*(L-L0)) + an

def beta(b0, kb, L, L0=0.1):
    return b0*np.exp(-kb*(L-L0))

livestock = [0.89, 3.1, 0.12, 0, 0]
nat_gas = [0.28, 4.2, 0.25, 0.09, 3.9]
landfills = [0, 0, 0.51, 0.08, 2.0]
wastewater = [0.78, 1.4, 0.21, 0.06, 6.9]
petroleum = [0, 0, 0.87, 0.04, 197]
sources = {'livestock' : livestock, 'nat_gas' : nat_gas,
           'landfills' : landfills, 'wastewater' : wastewater,
           'petroleum' : petroleum}

print('-'*75)
print('RESOLUTION DEPENDENT ERRORS')
print('-'*75)
print('RES    SECTOR              ALPHA BETA')
for ss, coefs in sources.items():
    a = alpha(coefs[0], coefs[1], coefs[2], 0.25)
    b = beta(coefs[3], coefs[4], 0.25)
    a2 = alpha(coefs[0], coefs[1], coefs[2], 0.3125)
    b2 = beta(coefs[3], coefs[4], 0.3125)

    print(f'0.25   {ss:<20}{a:.2f}  {b:.2f}')
    print(f'0.3125 {ss:<20}{a2:.2f}  {b2:.2f}')
print('-'*75)
print('\n')

## ------------------------------------------------------------------------ ##
## Define EPA errors 
## ------------------------------------------------------------------------ ##
EPA_err_min = pd.Series({'coal' : 0.06, 'gas' : 0.1, 'oil' : 0.12, 
                            'landfills' : 0.19, 'wastewater' : 0.01, 
                            'livestock' : 0.05, 'other' : 0.23,
                            'wetlands' : 0.5})

EPA_err_max = pd.Series({'coal' : 0.07, 'gas' : 0.15, 'oil' : 0.76, 
                            'landfills' : 0.33, 'wastewater' : 0.2, 
                            'livestock' : 0.07, 'other' : 0.5,
                             'wetlands' : 0.5})

## -------------------------------------------------------------------------##
## Load and process raw emissions data
## -------------------------------------------------------------------------##
emis_files = {'emis' : emis_file, 'emis_hr' : emis_hr_file}
emis = {}
for e_str, e_file in emis_files.items():
    print(e_str)
    emis[e_str] = gc.read_file(*e_file)

    # Remove emissions from buffer grid cells
    emis[e_str] = gc.subset_data_latlon(emis[e_str], *s.lats, *s.lons)

    # Drop hyam, hybm, and P0 (uneeded variables)
    emis[e_str] = emis[e_str].drop(['hyam', 'hybm', 'P0'])

    # Average over the year
    if 'time' in emis[e_str].dims:
        # Try comparing the two when you average correctly
        emis[e_str] = (emis[e_str]*days).sum(dim='time')/(days.sum())

        # # Average over time
        # emis[e_str] = emis[e_str].mean(dim='time')

        # Save summary files
        suff = e_str[4:]
        name = f'HEMCO_diagnostics{suff}.2019.nc'
        emis[f'{e_str}_correct'].to_netcdf(f'{data_dir}/prior/total_emissions/{name}')

        # name = 'HEMCO_diagnostics.2019.nc'
        # emis[e_str].to_netcdf(f'{data_dir}/prior/total_emissions/{name}')

    # Adjust units to Mg/km2/yr
    emis[f'{e_str}_correct'] *= 1e-3*(60*60*24*365)*(1000*1000)
    # emis[e_str] *= 1e-3*(60*60*24*365)*(1000*1000)

    # Fix area and convert to km2 from m2
    emis[f'{e_str}_correct']['AREA'] /= 1e-3*(60*60*24*365)*(1000*1000)**2
    # emis[e_str]['AREA'] /= 1e-3*(60*60*24*365)*(1000*1000)**2

# # Save out area as km2
# area = ip.clusters_2d_to_1d(clusters, emis['AREA'])
# area = xr.DataArray(area, dims=('nstate'))
# area.to_netcdf(join(data_dir, 'area.nc'))

# # Save out soil absorption and xa
# emis_dict = {'correct' : (emis_correct, '_correct'), 'orig' : (emis, '')}
# tot_emis = {}
# for label, ee in emis_dict.items():
#     # Isolate soil absorption
#     soil_abs = ee[0]['EmisCH4_SoilAbsorb']
#     soil_abs = ip.clusters_2d_to_1d(clusters, soil_abs)
#     soil_abs = xr.DataArray(soil_abs, dims=('nstate'))
#     soil_abs.to_netcdf(join(data_dir, f'soil_abs{ee[1]}.nc'))

#     # Calculate total emissions
#     te = ee[0]['EmisCH4_Total'] #- emis['EmisCH4_SoilAbsorb']
#     te = ip.clusters_2d_to_1d(clusters, te)
#     te = xr.DataArray(te, dims=('nstate'))
#     te.to_netcdf(join(data_dir, f'xa_abs{ee[1]}.nc'))
#     tot_emis[label] = te

# # Load Permian inventory
# permian_ong_edf = xr.open_dataset(f'{data_dir}/prior/permian/permian_EDF_2019.nc') # Originally kg/m2/s
# permian_ong_edf['EmisCH4_Oil'] *= 1e-3*(60*60*24*365)*(1000*1000) # -> Mg/km2/yr
# permian_ong_edf['EmisCH4_Gas'] *= 1e-3*(60*60*24*365)*(1000*1000)
# permian_condition = ((clusters.lat <= permian_ong_edf.lat.max()) &
#                      (clusters.lat >= permian_ong_edf.lat.min()) &
#                      (clusters.lon <= permian_ong_edf.lon.max()) &
#                      (clusters.lon >= permian_ong_edf.lon.min()))

# ## -------------------------------------------------------------------------##
# ## Tables
# ## -------------------------------------------------------------------------##
# # Print a summary table
# print('-'*75)
# print('SECTORAL EMISSIONS')
# print('-'*75)
# summ = emis_correct[[var for var in emis_correct.keys()
#                      if var[:4] == 'Emis']]*emis_correct['AREA']
# summ *= 1e-6 # Adjust units to Tg/yr
# # summ = summ.sum(dim=['lat', 'lon'])
# tally = 0    # Total tally
# tally_sv = 0 # The tally within the state vector
# for k in summ.keys():
#     # Get emissions within the state vector
#     k_all = summ[k].sum(dim=['lat', 'lon']).values
#     k_sv = ip.clusters_2d_to_1d(clusters, summ[k]).sum()
#     if k != 'EmisCH4_Total':
#         tally += k_all
#         tally_sv += k_sv
#     k_str = k.split('_')[-1]
#     if k_all != 0:
#         print(f'{k_str:>20} {k_all:5.2f} {k_sv:5.2f} {(100*k_sv/k_all):5.1f}%')
#     else:
#         print(f'{k_str:>20} {k_all:5.2f} {k_sv:5.2f}   ----')
# print('-'*75)
# print(f'               Total {tally:5.2f} {tally_sv:5.2f} {(100*tally_sv/tally):5.1f}%')
# print('-'*75)

# # Print a second summary table
# print('-'*75)
# print('SECTORAL NATIONAL EMISSIONS')
# print('-'*75)

# # Open masks and create a total_mask array as well as a mask dictionary
# mex_mask = np.load(f'{data_dir}/Mexico_mask.npy') #.reshape((-1, 1))
# can_mask = np.load(f'{data_dir}/Canada_mask.npy') #.reshape((-1, 1))
# conus_mask = np.load(f'{data_dir}/CONUS_mask.npy') #.reshape((-1, 1))
# other_mask = np.load(f'{data_dir}/Other_mask.npy') #.reshape((-1, 1))
# total_mask = mex_mask + can_mask + conus_mask + other_mask
# masks = pd.DataFrame.from_dict({'Canada' : can_mask, 'CONUS' : conus_mask, 
#                                 'Mexico' : mex_mask, 'Other' : other_mask})

# e_table = {'Natural' : {'Wetlands' : ['Wetlands'],
#                         'Open fires' : ['BiomassBurn'],
#                         'Termites' : ['Termites'],
#                         'Geological seeps' : ['Seeps'],
#                         'Other natural' : ['Lakes']},
#            'Anthropogenic' : {'Livestock' : ['Livestock'],
#                               # 'Oil' : ['Oil'], 'Gas' : ['Gas'],
#                               'Oil and gas' : ['Oil', 'Gas'],
#                               'Landfills' : ['Landfills'],
#                               'Coal mining' : ['Coal'],
#                               'Wastewater' : ['Wastewater'],
#                               'Rice cultivation' : ['Rice'],
#                               'Other anthropogenic' : ['OtherAnth']}}

# summ = emis_correct[[var for var in emis_correct.keys() if var[:4] == 'Emis']]
# summ *= 1e-6 # Tg/km2/yr

# # # Correct for wetlands
# # summ['EmisCH4_Wetlands'] /= 4.04

# # # Correct for EDF
# # summ['EmisCH4_Oil_EDF'] = dc(permian_ong_edf['EmisCH4_Oil'])
# # summ['EmisCH4_Gas_EDF'] = dc(permian_ong_edf['EmisCH4_Gas'])
# # summ['EmisCH4_Oil'] = summ['EmisCH4_Oil'].where(~permian_condition, 
# #                                                 summ['EmisCH4_Oil_EDF'])
# # summ['EmisCH4_Gas'] = summ['EmisCH4_Gas'].where(~permian_condition, 
# #                                                 summ['EmisCH4_Gas_EDF'])

# # Convert from Tg/km2/yr to Tg/yr
# summ *= emis_correct['AREA']

# c = masks.columns.values
# print(f'Source                {c[0]:>10}{c[1]:>10}{c[2]:>10}{c[3]:>10}     Total')
# print('-'*75)
# # print(f'{'Canada':25}')
# ttotal = [0, 0, 0, 0]
# for label, big_cat in e_table.items():
#     total = [0, 0, 0, 0]
#     print(f'{label}')
#     for cat, sources in big_cat.items():
#         # Get gridded emissions sum
#         e = sum(summ[f'EmisCH4_{s}'].squeeze() for s in sources)

#         # Flatten
#         e = ip.clusters_2d_to_1d(clusters, e).reshape((-1, 1))

#         # Apply mask and sum
#         e = (e*masks).sum(axis=0).values
#         total = [total[i] + e[i] for i in range(4)]

#         print(f'  {cat:20}{e[0]:10.3f}{e[1]:10.3f}{e[2]:10.3f}{e[3]:10.3f}{sum(e):10.3f}')
#         #{e['CONUS']:5.2f}{e['Mexico']:5.2f}{e['Other']:5.2f}')
#         # print(cat, e)
#         # print(cat, sources)
#     print(f'  Total               {total[0]:10.3f}{total[1]:10.3f}{total[2]:10.3f}{total[3]:10.3f}{sum(total):10.3f}')
#     ttotal = [ttotal[i] + total[i] for i in range(4)]

# print(f'Total                 {ttotal[0]:10.3f}{ttotal[1]:10.3f}{ttotal[2]:10.3f}{ttotal[3]:10.3f}{sum(ttotal):10.3f}')

# print('-'*75)

# ## -------------------------------------------------------------------------##
# ## Group by sector
# ## -------------------------------------------------------------------------##
# def sectoral_matrix(raw_emis, suffix, area=area,
#                     clusters=clusters, emis_cats=emissions):
#     w = pd.DataFrame(columns=emis_cats.keys())
#     for label, categories in emis_cats.items():
#         # Get emissions
#         if type(categories) == str:
#             e = raw_emis['EmisCH4_%s' % categories].squeeze()
#         elif type(categories) == list:
#             e = sum(raw_emis['EmisCH4_%s' % em].squeeze()
#                     for em in categories)

#         # Flatten
#         e = ip.clusters_2d_to_1d(clusters, e)

#         # Convert to Mg/yr
#         e *= area

#         # Saveout
#         w[label] = e

#     w.to_csv(join(data_dir, f'w{suffix}.csv'), index=False)
#     return w

# w_correct = sectoral_matrix(emis_correct, '_correct')
# w = sectoral_matrix(emis, '')

# print('-'*75)
# print('Standard emissions')
# print(w_correct.sum(axis=0)*1e-6)
# print('total         ', w_correct.values.sum()*1e-6 +
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (tot_emis['correct']*area).sum().values*1e-6)

# ## -------------------------------------------------------------------------##
# ## Get sectoral errors
# ## -------------------------------------------------------------------------##
# sect_err_max = np.sqrt(((w_correct*EPA_err_max)**2).sum(axis=1))/w_correct.sum(axis=1).values
# sect_err_max = np.array(sect_err_max)
# sect_err_max = np.nan_to_num(sect_err_max, 0.5)
# sect_err_max[sect_err_max == 0.0] = 0.5

# sect_err_min = np.sqrt(((w_correct*EPA_err_min)**2).sum(axis=1))/w_correct.sum(axis=1).values
# sect_err_min = np.array(sect_err_min)
# sect_err_min = np.nan_to_num(sect_err_min, 0.5)
# sect_err_min[sect_err_min == 0] = 0.5

# # cbar_kwargs = {'title' : r'Relative errors'}
# # small_map_kwargs = {'draw_labels' : False}
# # small_fig_kwargs = {'max_width' : 4,
# #                     'max_height' : 3.5}
# # emis_kwargs = {'cmap' : fp.cmap_trans('viridis'), 'vmin' : 0, 'vmax' : 0.5,
# #                'default_value' : 0, 'cbar_kwargs' : cbar_kwargs, 
# #                'fig_kwargs' : small_fig_kwargs, 
# #                'map_kwargs' : small_map_kwargs}
# # # fig, ax = fp.get_figax(rows=1, cols=2, maps=True,
# # #                        lats=emis_correct.lat, lons=emis_correct.lon)
# # plt.subplots_adjust(hspace=0.5)
# # # fig, ax[0], c = ip.plot_state(sect_err_min, clusters, cbar=False,
# # #                               title='Minimum sectoral errors',
# # #                               fig_kwargs={'figax' : [fig, ax[0]]},
# # #                               **emis_kwargs)
# # fig, ax, c = ip.plot_state(sect_err_max, clusters, #cbar=False,
# #                               title='Sectoral errors',
# #                               # fig_kwargs={'figax' : [fig, ax[1]]},
# #                               **emis_kwargs)
# # # cax = fp.add_cax(fig, ax, cbar_pad_inches=0.5)
# # # cb = fig.colorbar(c, cax=cax, ticks=np.arange(0, 0.6, 0.1))
# # # cb = fp.format_cbar(cb, cbar_title=r'Relative errors') 
# # fp.save_fig(fig, plot_dir, 'sectoral_errors')

# ## -------------------------------------------------------------------------##
# ## Sensitivity tests: Boundary condition
# ## -------------------------------------------------------------------------##
# # Get indices corresponding to the functional boundary condition correction
# bc_idx = clusters.where(clusters.lat > s.lat_max - 3*s.lat_delta, drop=True)
# bc_idx = bc_idx.values.astype(int)
# bc_idx = bc_idx[bc_idx > 0] - 1
# bc_idx.sort()

# # Set these to zero in the absolute prior
# xa_abs_bc0 = dc(tot_emis['correct'])
# xa_abs_bc0[bc_idx] = 0
# xa_abs_bc0.to_netcdf(join(data_dir, 'xa_abs_bc0.nc'))

# # We can use the same sectoral breakdown as w_correct.

# ## -------------------------------------------------------------------------##
# ## Sensitivity tests: Permian
# ## -------------------------------------------------------------------------##
# ## Permian: EDF inventory instead of EPA inventory
# # a. Subset the full clusters over the Permian
# permian_clusters = clusters.where(permian_condition, drop=True)

# # b. Flatten and create list of indices
# permian_idx = permian_clusters.values.reshape(-1,)
# permian_idx = np.sort(permian_idx)
# permian_idx = permian_idx[permian_idx > 0]
# permian_idx = (permian_idx - 1).astype(int)

# # c. Subset total prior emissions and oil and natural gas emissions over
# # the Permian (Mg/km2/yr)
# xa_abs_permian = tot_emis['correct'][permian_idx]
# # xa_abs_permian_ong_epa = (w_correct['oil'] + w_correct['gas'])[permian_idx]
# xa_abs_permian_ong_epa = w_correct['ong'][permian_idx]/area[permian_idx]

# # d. Get the EDF prior, subset over the Permian, and match units
# permian_ong_edf = xr.open_dataset(f'{data_dir}/prior/permian/permian_EDF_2019.nc') # Originally kg/m2/s
# permian_o_edf = permian_ong_edf['EmisCH4_Oil']*1e-3*(60*60*24*365)*(1000*1000)
# permian_ng_edf = permian_ong_edf['EmisCH4_Gas']*1e-3*(60*60*24*365)*(1000*1000)

# # e. Convert to 1D
# xa_abs_permian_o_edf = ip.clusters_2d_to_1d(permian_clusters, permian_o_edf)
# xa_abs_permian_ng_edf = ip.clusters_2d_to_1d(permian_clusters, permian_ng_edf)

# # f. Calculate the new total emissions over the Permian and replace them in
# # the whole state vector
# xa_abs_permian += (xa_abs_permian_o_edf + xa_abs_permian_ng_edf
#                    - xa_abs_permian_ong_epa)
# xa_abs_edf = dc(tot_emis['correct'])
# xa_abs_edf[permian_idx] = xa_abs_permian

# # g. Calculate a new sectoral attribution matrix
# w_edf = dc(w_correct)
# # w_edf['oil'][permian_idx] = xa_abs_permian_o_edf
# # w_edf['gas'][permian_idx] = xa_abs_permian_ng_edf
# w_edf['ong'][permian_idx] = (xa_abs_permian_o_edf + xa_abs_permian_ng_edf)*area[permian_idx]

# # h. Save out
# xa_abs_edf = xr.DataArray(xa_abs_edf, dims=('nstate'))
# xa_abs_edf.to_netcdf(join(data_dir, 'xa_abs_edf.nc'))
# w_edf.to_csv(join(data_dir, f'w_edf.csv'), index=False)

# print('-'*75)
# print('EDF inventory emissions')
# print(w_edf.sum(axis=0)*1e-6)
# print('total         ', w_edf.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_edf*area).sum().values*1e-6)

# ## -------------------------------------------------------------------------##
# ## Sensitivity tests: Wetlands
# ## -------------------------------------------------------------------------##
# ## 50% wetlands
# # xa_abs
# xa_abs_w50 = dc(tot_emis['correct'])
# xa_abs_w50 -= 0.5*w_correct['wetlands']/area
# xa_abs_w50.to_netcdf(join(data_dir, 'xa_abs_w50.nc'))

# # Sectoral attribution matrix
# w_w50 = dc(w_correct)
# w_w50['wetlands'] *= 0.5
# w_w50.to_csv(join(data_dir, f'w_w50.csv'), index=False)

# print('-'*75)
# print('50% wetland emissions')
# print(w_w50.sum(axis=0)*1e-6)
# print('total         ', w_w50.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_w50*area).sum().values*1e-6)

# ## 25% wetlands
# # xa_abs
# xa_abs_w404 = dc(tot_emis['correct'])
# xa_abs_w404 -= (3.04/4.04)*w_correct['wetlands']/area
# xa_abs_w404.to_netcdf(join(data_dir, 'xa_abs_w404.nc'))

# # Sectoral attribution matrix
# w_w404 = dc(w_correct)
# w_w404['wetlands'] /= 4.04
# w_w404.to_csv(join(data_dir, f'w_w404.csv'), index=False)

# print('-'*75)
# print('Wetlands divided by 4.04 emissions')
# print(w_w404.sum(axis=0)*1e-6)
# print('total         ', w_w404.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_w404*area).sum().values*1e-6)

# ## Remove ensemble members 3 (1923) and 7 (2913). The prep work for
# ## this test was done in wetlands.py
# # Load in HEMCO_diagnostics (this code is commented above)
# emis_w37_file = [f'{data_dir}/prior/wetlands/wetlands37/\
# HEMCO_diagnostics.{s.year:04d}{mm:02d}010000.nc'
#              for mm in s.months]
# emis_w37 = gc.read_file(*emis_w37_file)
# emis_w37 = gc.subset_data_latlon(emis_w37, *s.lats, *s.lons)
# emis_w37 = emis_w37.drop(['hyam', 'hybm', 'P0'])
# emis_w37 = (emis_w37*days).sum(dim='time')/(days.sum())
# emis_w37.to_netcdf(f'{data_dir}/prior/wetlands/HEMCO_diagnostics_w37.2019.nc')
# emis_w37 *= 1e-3*(60*60*24*365)*(1000*1000) # --> Mg/km2/yr
# emis_w37['AREA'] /= 1e-3*(60*60*24*365)*(1000*1000)**2

# xa_abs_w37 = ip.clusters_2d_to_1d(clusters, emis_w37['EmisCH4_Total'])
# xa_abs_w37 = xr.DataArray(xa_abs_w37, dims=('nstate'))
# xa_abs_w37.to_netcdf(join(data_dir, 'xa_abs_w37.nc'))

# # Sectoral attribution matrix
# w_w37 = sectoral_matrix(emis_w37, '_w37')

# print('-'*75)
# print('Removed wetland ensemble members emissions')
# print(w_w37.sum(axis=0)*1e-6)
# print('total         ', w_w37.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_w37*area).sum().values*1e-6)

# ## -------------------------------------------------------------------------##
# ## Sensitivity tests: Combination
# ## -------------------------------------------------------------------------##
# # # EDF and BC0
# # xa_abs_edf_bc0 = dc(xa_abs_edf)
# # xa_abs_edf_bc0[bc_idx] = 0
# # xa_abs_edf_bc0.to_netcdf(join(data_dir, 'xa_abs_edf_bc0.nc'))

# # # Wetlands 4.04 and BC0
# # xa_abs_w404_bc0 = dc(xa_abs_w404)
# # xa_abs_w404_bc0[bc_idx] = 0
# # xa_abs_w404_bc0.to_netcdf(join(data_dir, 'xa_abs_w404_bc0.nc'))

# # EDF and Wetlands 4.04
# xa_abs_w404_edf = dc(xa_abs_edf)
# xa_abs_w404_edf -= (3.04/4.04)*w_correct['wetlands']/area
# xa_abs_w404_edf.to_netcdf(join(data_dir, 'xa_abs_w404_edf.nc'))

# w_w404_edf = dc(w_correct)
# w_w404_edf['wetlands'] /= 4.04
# w_w404_edf['ong'] = dc(w_edf['ong'])
# w_w404_edf.to_csv(join(data_dir, 'w_w404_edf.csv'), index=False)

# print('-'*75)
# print('Wetlands divided by 4.04 emissions and EDF inventory')
# print(w_w404_edf.sum(axis=0)*1e-6)
# print('total         ', w_w404_edf.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_w404_edf*area).sum().values*1e-6)

# # EDF and Wetlands 37
# xa_abs_w37_edf = dc(xa_abs_edf) + (w_w37['wetlands'] - w_correct['wetlands'])/area
# xa_abs_w37_edf.to_netcdf(join(data_dir, 'xa_abs_w37_edf.nc'))

# w_w37_edf = dc(w_correct)
# w_w37_edf['wetlands'] = dc(w_w37['wetlands'])
# w_w37_edf['ong'] = dc(w_edf['ong'])
# w_w37_edf.to_csv(join(data_dir, 'w_w37_edf.csv'), index=False)

# print('-'*75)
# print('Removed wetland ensemble members emissions and EDF inventory')
# print(w_w37_edf.sum(axis=0)*1e-6)
# print('total         ', w_w37_edf.values.sum()*1e-6 + 
#                         (soil_abs*area).values.sum()*1e-6)
# print('total         ', (xa_abs_w37_edf*area).sum().values*1e-6)
# print('-'*75)

# # EDF, Wetlands 4.04, and BC0
# xa_abs_w404_edf_bc0 = dc(xa_abs_w404_edf)
# xa_abs_w404_edf_bc0[bc_idx] = 0
# xa_abs_w404_edf_bc0.to_netcdf(join(data_dir, 'xa_abs_w404_edf_bc0.nc'))

# # EDF, Wetlands 37, and BC0
# xa_abs_w37_edf_bc0 = dc(xa_abs_w37_edf)
# xa_abs_w37_edf_bc0[bc_idx] = 0
# xa_abs_w37_edf_bc0.to_netcdf(join(data_dir, 'xa_abs_w37_edf_bc0.nc'))

# # # EDF and Wetlands 50
# # xa_abs_w50_edf = dc(xa_abs_edf)
# # xa_abs_w50_edf -= 0.5*w_correct['wetlands']
# # xa_abs_w50_edf.to_netcdf(join(data_dir, 'xa_abs_w50_edf.nc'))

# ## -------------------------------------------------------------------------##
# ## Plot
# ## -------------------------------------------------------------------------##
# if plot_dir is not None:
#     plot_e = {'Total' : ['Total'],
#               'Oil and gas' : ['OilAndGas'], #'Gas' : ['Gas'], 
#               'Coal' : ['Coal'],
#               'Livestock' : ['Livestock'], 
#               'Landfills' : ['Landfills'],
#               'Wastewater' : ['Wastewater'], 
#               'Wetlands' : ['Wetlands37'],
#               'Other' : ['Other']}#,
#               # 'Open Fires' : ['BiomassBurn']}
#     # Rice, Termites, Seeps, Lakes, OtherAnth are missing
#     plot_e_terms = [item for sublist in plot_e.values() for item in sublist]

#     # Set colormap
#     colormap = fp.cmap_trans('viridis')

#     # Update emissions
#     e_c = dc(emis_correct)

#     # Save out the wetlands that we actually use
#     # e_c['EmisCH4_Wetlands404'] = e_c['EmisCH4_Wetlands']/4.04
#     e_c['EmisCH4_Wetlands37'] = emis_w37['EmisCH4_Wetlands']

#     # Bring in the EDF emissions
#     e_c['EmisCH4_OilAndGas'] = ip.match_data_to_clusters(w_edf['ong']/area,
#                                                          clusters)
#     # e_c['EmisCH4_Gas'] = dc(summ['EmisCH4_Gas'])*1e6
#     # e_c['EmisCH4_Oil'] = dc(summ['EmisCH4_Oil'])*1e6

#     # Sum up other
#     e_c['EmisCH4_Other'] = sum(e_c[f'EmisCH4_{s}'] for s 
#                                in ['BiomassBurn', 'Termites', 'Seeps', 'Lakes',
#                                    'Rice', 'OtherAnth'])

#     # Update total
#     e_c['EmisCH4_Total'] = sum(e_c[f'EmisCH4_{s}'] for s in plot_e_terms
#                                if s not in 
#                                ['Total'])
#     # e_c['EmisCH4_Total'] += (e_c['EmisCH4_Wetlands404'] + e_c['EmisCH4_Wetlands37'])/2

#     # Plot
#     fig, ax = fp.get_figax(rows=2, cols=4, maps=True,
#                            lats=e_c.lat, lons=e_c.lon)
#     for axis, (title, emis_list) in zip(ax.flatten(), plot_e.items()):
#         print(title, emis_list)
#         axis = fp.format_map(axis, lats=e_c.lat, lons=e_c.lon)
#         e = sum(e_c[f'EmisCH4_{em}'].squeeze() for em in emis_list)
#         c = e.plot(ax=axis, cmap=colormap, vmin=0, vmax=5,
#                    add_colorbar=False)
#         axis.text(0.025, 0.025, title, ha='left', va='bottom', 
#                   fontsize=config.TICK_FONTSIZE,
#                   transform=axis.transAxes)
#     plt.subplots_adjust(hspace=-0.25, wspace=0.1)
#     cax = fp.add_cax(fig, ax, horizontal=False)#, cbar_pad_inches=0.2)
#     cb = fig.colorbar(c, cax=cax, ticks=np.arange(0, 6, 1), 
#                       orientation='vertical')
#     cb = fp.format_cbar(cb, cbar_title=r'Initial emissions estimate (Mg km$^2$ a$^{-1}$)',
#                         horizontal=False, y=-3)
#     fp.save_fig(fig, plot_dir, 'prior_emissions_2019')

#     # Create another plot comparing orig and correct
#     fig, ax = fp.get_figax(rows=1, cols=3, maps=True, 
#                            lats=emis_correct.lat, lons=emis_correct.lon)
#     for i, axis in enumerate(ax.flatten()):
#         axis = fp.format_map(axis, lats=emis_correct.lat, lons=emis_correct.lon)

#     # Mg/km2/yr
#     e = tot_emis['orig']
#     fig, ax[0], c = ip.plot_state(e, clusters, cmap=colormap, vmin=0, vmax=5,
#                                  title='Original prior',
#                                  fig_kwargs={'figax' : [fig, ax[0]]})

#     e = tot_emis['correct']
#     fig, ax[1], c = ip.plot_state(e, clusters, cmap=colormap, vmin=0, vmax=5,
#                                  title='Correct prior',
#                                  fig_kwargs={'figax' : [fig, ax[1]]})

#     rat = tot_emis['correct']/tot_emis['orig']
#     fig, ax[2], c = ip.plot_state(rat, clusters, cmap='RdBu_r', vmin=0, vmax=2, 
#                                   title='Ratio', default_value=1,
#                                   fig_kwargs={'figax' : [fig, ax[2]]})
#     fp.save_fig(fig, plot_dir, 'corrected_prior')

#     # fig, ax = fp.get_figax(aspect=2)
#     # ax.hist(rat, bins=100)
#     # fp. save_fig(fig, plot_dir, 'corrected_prior_ratio_hist')

# # Select total emissions
# # emis = emis['EmisCH4_Total']

# print('The minimum positive emission is',
#       np.abs(emis['EmisCH4_Total'].where(emis['EmisCH4_Total'] > 0).min()).values)

# ## -------------------------------------------------------------------------##
# ## Generate prior and prior error covariance
# ## -------------------------------------------------------------------------##
# # # Relative prior
# # xa = np.ones(nstate)
# # xa = xr.DataArray(xa, dims=('nstate'))
# # xa.to_netcdf(join(data_dir, 'xa.nc'))

# # Relative errors
# sa = rel_err**2*np.ones(nstate)
# sa = xr.DataArray(sa, dims=('nstate'))
# sa.to_netcdf(join(data_dir, 'sa.nc'))

# # # Absolute prior
# # xa_abs = ip.clusters_2d_to_1d(clusters, emis)
# # xa_abs = xr.DataArray(xa_abs, dims=('nstate'))
# # xa_abs.to_netcdf(join(data_dir, 'xa_abs.nc'))

# # Absolute errors
# sa_abs = sa*tot_emis['correct']**2
# sa_abs.to_netcdf(join(data_dir, 'sa_abs.nc'))

# # Variable errors
# sa_var_max = xr.DataArray(sect_err_max**2, dims=('nstate'))
# sa_var_max.to_netcdf(join(data_dir, 'sa_var_max.nc'))

# sa_var_min = xr.DataArray(sect_err_min**2, dims=('nstate'))
# sa_var_min.to_netcdf(join(data_dir, 'sa_var_min.nc'))

# # # Varying errors
# # sa_var = 1*tot_emis.mean()/tot_emis
# # sa_var[sa_var < 1] = 1
# # sa_var[sa_var > 5] = 5
# # sa_var = sa_var**2
# # sa_var.to_netcdf(join(data_dir, 'sa_var.nc'))

# # s_a_vec = 0.5*x_a.mean()/x_a
# # s_a_vec[s_a_vec < 0.5] = 0.5
