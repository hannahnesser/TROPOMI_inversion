'''
This script generates netcdfs of the absolute and relative prior emissions and error variances for use in an analytical inversion.

   **Inputs**

   | ----------------- | -------------------------------------------------- |
   | Input             | Description                                        |
   | ----------------- | -------------------------------------------------- |
   | emis_file         | A file or files containing information on methane  |
   |                   | emissions from the prior run. This is typically    |
   |                   | given by HEMCO_diagnostics. The input here can be  |
   |                   | either a list of monthly files or a single file    |
   |                   | with an annual average.                            |
   | ----------------- | -------------------------------------------------- |
   | clusters          | The cluster file generated by generate_clusters.py |
   |                   | that maps a unique key for every grid cell         |
   |                   | contained in the state vector to the latitude-     |
   |                   |longitude grid used in the forward model.           |
   | ----------------- | -------------------------------------------------- |
   | rel_err           | The relative error (standard deviation) value to   |
   |                   | be used in the relative prior error covariance     |
   |                   | matrix. The default is 0.5.                        |
   | ----------------- | -------------------------------------------------- |

   **Outputs**

   | ----------------- | -------------------------------------------------- |
   | Output            | Description                                        |
   | ----------------- | -------------------------------------------------- |
   | xa.nc             | A netcdf containing the relative prior (all ones)  |
   |                   | xa for use in the inversion.                       |
   | ----------------- | -------------------------------------------------- |
   | sa.nc             | A netcdf containing the relative prior error (all  |
   |                   | given by rel_err) for use in the inversion.        |
   | ----------------- | -------------------------------------------------- |
   | xa_abs.nc         | A netcdf containing the absolute prior (all ones)  |
   |                   | xa for use in the inversion.                       |
   | ----------------- | -------------------------------------------------- |
   | sa_abs.nc         | A netcdf containing the absolute prior error (all  |
   |                   | given by rel_err) for use in the inversion.        |
   | ----------------- | -------------------------------------------------- |
'''

from os.path import join
import sys
import copy

import math
import numpy as np
import pandas as pd
import xarray as xr

import matplotlib.pyplot as plt

# Custom packages
sys.path.append('.')
import config
# config.SCALE = config.PRES_SCALE
# config.BASE_WIDTH = config.PRES_WIDTH
# config.BASE_HEIGHT = config.PRES_HEIGHT
import gcpy as gc
import troppy as tp
import invpy as ip
import format_plots as fp
import inversion_settings as s

## ------------------------------------------------------------------------ ##
## Set user preferences
## ------------------------------------------------------------------------ ##
base_dir = '/Users/hannahnesser/Documents/Harvard/Research/TROPOMI_Inversion/'
code_dir = base_dir + 'python'
data_dir = base_dir + 'inversion_data'
plot_dir = base_dir + 'plots'

# The emissions can either be a list of files or a single file
# with an annual average
emis_file = [f'{base_dir}/prior/total_emissions/\
HEMCO_diagnostics.{s.year:04d}{mm:02d}010000.nc'
             for mm in s.months]
# emis_file = f'{base_dir}/prior/total_emissions/HEMCO_diagnostics.{s.year}.nc'
clusters = f'{data_dir}/clusters.nc'
clusters = xr.open_dataarray(clusters)
nstate = int(clusters.max().values)
print(f'n = {nstate}')

# Set relative prior error covariance value
rel_err = 1

# Sectoral breakdown
emissions = {'wetlands' : 'Wetlands',
             'livestock' : 'Livestock',
             'coal' : 'Coal',
             'oil' : 'Oil',
             'gas' : 'Gas',
             'landfills' : 'Landfills',
             'wastewater' : 'Wastewater',
             'other' : ['Termites', 'Seeps', 'BiomassBurn', 'Lakes', 'Rice', 'OtherAnth']}

## ------------------------------------------------------------------------ ##
## Figure out what the relative prior errors should be set at
## ------------------------------------------------------------------------ ##
def alpha(a0, ka, an, L, L0=0.1):
    return a0*np.exp(-ka*(L-L0)) + an

def beta(b0, kb, L, L0=0.1):
    return b0*np.exp(-kb*(L-L0))

livestock = [0.89, 3.1, 0.12, 0, 0]
nat_gas = [0.28, 4.2, 0.25, 0.09, 3.9]
landfills = [0, 0, 0.51, 0.08, 2.0]
wastewater = [0.78, 1.4, 0.21, 0.06, 6.9]
petroleum = [0, 0, 0.87, 0.04, 197]
sources = {'livestock' : livestock, 'nat_gas' : nat_gas,
           'landfills' : landfills, 'wastewater' : wastewater,
           'petroleum' : petroleum}

print('-'*50)
print('RESOLUTION DEPENDENT ERRORS')
print('-'*50)
print('RES    SECTOR              ALPHA BETA')
for ss, coefs in sources.items():
    a = alpha(coefs[0], coefs[1], coefs[2], 0.25)
    b = beta(coefs[3], coefs[4], 0.25)
    a2 = alpha(coefs[0], coefs[1], coefs[2], 0.3125)
    b2 = beta(coefs[3], coefs[4], 0.3125)

    print(f'0.25   {ss:<20}{a:.2f}  {b:.2f}')
    print(f'0.3125 {ss:<20}{a2:.2f}  {b2:.2f}')
print('-'*50)
print('\n')

## -------------------------------------------------------------------------##
## Load raw emissions data
## -------------------------------------------------------------------------##
emis = gc.read_file(*emis_file)

# Remove emissions from buffer grid cells
emis = gc.subset_data_latlon(emis, *s.lats, *s.lons)

days = xr.DataArray([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                    dims='time')
if 'time' in emis.dims:
    # Try comparing the two when you average correctly
    emis_correct = (emis*days).sum(dim='time')/(days.sum())
    # print(emis2)

    # Average over time
    emis = emis.mean(dim='time')

    # Save summary files
    name = 'HEMCO_diagnostics_correct.2019.nc'
    emis_correct.to_netcdf(f'{base_dir}/prior/total_emissions/{name}')

    name = 'HEMCO_diagnostics.2019.nc'
    emis.to_netcdf(f'{base_dir}/prior/total_emissions/{name}')

# Save out area as km2
area = emis['AREA']/(1000*1000)
area = ip.clusters_2d_to_1d(clusters, area)
area = xr.DataArray(area, dims=('nstate'))
area.to_netcdf(join(data_dir, 'area.nc'))

# Print a summary table
print('-'*50)
print('SECTORAL EMISSIONS')
print('-'*50)
summ = emis_correct[[var for var in emis_correct.keys()
                     if var[:4] == 'Emis']]*emis_correct['AREA']
summ *= 1e-9*(60*60*24*365) # Adjust units to Tg/yr
# summ = xr.where(clusters > 0)
summ = summ.sum(dim=['lat', 'lon'])
tally = 0
for k in summ.keys():
    if k != 'EmisCH4_Total':
        tally += summ[k].values
    print(f'{k:>20} {summ[k].values:.2f}')
print('-'*50)
print(f'               Total {tally:.2f}')
print('-'*50)

# Adjust units to Mg/km2/yr
emis_correct *= 1e-3*(60*60*24*365)*(1000*1000)
emis *= 1e-3*(60*60*24*365)*(1000*1000)

emis_dict = {'correct' : (emis_correct, '_correct'), 'orig' : (emis, '')}
tot_emis = {}
for label, ee in emis_dict.items():
    # Isolate soil absorption
    soil_abs = ee[0]['EmisCH4_SoilAbsorb']
    soil_abs = ip.clusters_2d_to_1d(clusters, soil_abs)
    soil_abs = xr.DataArray(soil_abs, dims=('nstate'))
    soil_abs.to_netcdf(join(data_dir, f'soil_abs{ee[1]}.nc'))

    # Calculate total emissions
    te = ee[0]['EmisCH4_Total'] #- emis['EmisCH4_SoilAbsorb']
    te = ip.clusters_2d_to_1d(clusters, te)
    te = xr.DataArray(te, dims=('nstate'))
    te.to_netcdf(join(data_dir, f'xa_abs{ee[1]}.nc'))
    tot_emis[label] = te

## -------------------------------------------------------------------------##
## Group by sector
## -------------------------------------------------------------------------##
def sectoral_matrix(raw_emis, suffix, clusters=clusters, emis_cats=emissions):
    w = pd.DataFrame(columns=emis_cats.keys())
    for label, categories in emis_cats.items():
        # Get emissions
        if type(categories) == str:
            e = raw_emis['EmisCH4_%s' % categories].squeeze()
        elif type(categories) == list:
            e = sum(raw_emis['EmisCH4_%s' % em].squeeze()
                    for em in categories)

        # Flatten
        e = ip.clusters_2d_to_1d(clusters, e)

        # Saveout
        # e = xr.DataArray(e, dims=('nstate'))
        # e.to_netcdf(join(data_dir, f'xa_{label}.nc'))
        w[label] = e
        # print(label)
        # print(e)

    w.to_csv(join(data_dir, f'w{suffix}.csv'), index=False)
    return w

w_correct = sectoral_matrix(emis_correct, '_correct')
w = sectoral_matrix(emis, '')

## -------------------------------------------------------------------------##
## Sensitivity tests: Boundary condition
## -------------------------------------------------------------------------##
# Get indices corresponding to the functional boundary condition correction
bc_idx = clusters.where(clusters.lat > s.lat_max - 3*s.lat_delta, drop=True)
bc_idx = bc_idx.values.astype(int)
bc_idx = bc_idx[bc_idx > 0] - 1
bc_idx.sort()

# Set these to zero in the absolute prior
xa_abs_bc0 = copy.deepcopy(tot_emis['correct'])
xa_abs_bc0[bc_idx] = 0
xa_abs_bc0.to_netcdf(join(data_dir, 'xa_abs_bc0.nc'))

# We can use the same sectoral breakdown as w_correct.

## -------------------------------------------------------------------------##
## Sensitivity tests: Permian
## -------------------------------------------------------------------------##
### Permian: EDF inventory instead of EPA inventory
## 1. Get a list of state vector indices over the Permian
# a. Open the Permian clusters
permian = xr.open_dataset(f'{data_dir}/clusters_permian.nc')['Clusters']

# b. Append the Permian clusters to the North American clusters
c = clusters.squeeze(drop=True).to_dataset()
c['Permian'] = permian

# c. Discard the buffer cells
cell_idx, cell_cnt  = np.unique(c['Permian'], return_counts=True)
cell_idx = cell_idx[cell_cnt == 1]
cell_idx = cell_idx[~np.isnan(cell_idx)]
permian = permian.where(permian.isin(cell_idx), 0)

# d. Subset the full clusters over the Permian
c = c.where(c['Permian'].isin(cell_idx))['Clusters']
c = c.sel(lat=permian.lat, lon=permian.lon)

# e. Flatten and create list of indices
permian_idx = (ip.clusters_2d_to_1d(permian, c) - 1).astype(int)

# f. Save
np.save(f'{data_dir}/permian_idx.npy', permian_idx)

## 2. Subset total prior emissions and oil and natural gas emissions over
## the Permian (Mg/km2/yr)
xa_abs_permian = tot_emis['correct'][permian_idx]
xa_abs_permian_ong_epa = (w_correct['oil'] + w_correct['gas'])[permian_idx]

## 3. Get the EDF prior and subset over the Permian
permian_ong_edf = xr.open_dataset(f'{base_dir}/prior/permian/permian_EDF_2019.nc') # Originally kg/m2/s
permian_o_edf = permian_ong_edf['EmisCH4_Oil']*1e-3*(60*60*24*365)*(1000*1000)
permian_ng_edf = permian_ong_edf['EmisCH4_Gas']*1e-3*(60*60*24*365)*(1000*1000)
xa_abs_permian_o_edf = ip.clusters_2d_to_1d(permian, permian_o_edf)
xa_abs_permian_ng_edf = ip.clusters_2d_to_1d(permian, permian_ng_edf)

## 4. Calculate the new total emissions over the Permian and replace them in
## the whole state vector
xa_abs_permian += (xa_abs_permian_o_edf + xa_abs_permian_ng_edf
                   - xa_abs_permian_ong_epa)
xa_abs_edf = copy.deepcopy(tot_emis['correct'])
xa_abs_edf[permian_idx] = xa_abs_permian

## 4. Calculate a new sectoral attribution matrix
w_edf = copy.deepcopy(w_correct)
w_edf['oil'][permian_idx] = xa_abs_permian_o_edf
w_edf['gas'][permian_idx] = xa_abs_permian_ng_edf

## 5. Save out
xa_abs_edf = xr.DataArray(xa_abs_edf, dims=('nstate'))
xa_abs_edf.to_netcdf(join(data_dir, 'xa_abs_edf.nc'))
w_edf.to_csv(join(data_dir, f'w_edf.csv'), index=False)

## -------------------------------------------------------------------------##
## Sensitivity tests: Wetlands
## -------------------------------------------------------------------------##
### 50% wetlands
# xa_abs
xa_abs_wetlands50 = copy.deepcopy(tot_emis['correct'])
xa_abs_wetlands50 -= 0.5*w_correct['wetlands']
xa_abs_wetlands50.to_netcdf(join(data_dir, 'xa_abs_wetlands50.nc'))

# Sectoral attribution matrix
w_wetlands50 = copy.deepcopy(w_correct)
w_wetlands50['wetlands'] *= 0.5
w_wetlands50.to_csv(join(data_dir, f'w_wetlands50.csv'), index=False)

## Remove ensemble members 3 (1923) and 7 (2913). The prep work for
## this test was done in wetlands.py
wetlands37 = xr.open_dataarray(f'{base_dir}/prior/wetlands/wetlands37.nc')
wetlands37 = ip.clusters_2d_to_1d(clusters, wetlands37)
wetlands37 *= 1e-3*(60*60*24*365)*(1000*1000) # kg/m2/s --> Mg/km2/yr
xa_abs_wetlands37 = copy.deepcopy(tot_emis['correct'])
xa_abs_wetlands37 = xa_abs_wetlands37 - w_correct['wetlands'] + wetlands37
xa_abs_wetlands37.to_netcdf(join(data_dir, 'xa_abs_wetlands37.nc'))

# Sectoral attribution matrix
w_wetlands37 = copy.deepcopy(w_correct)
w_wetlands37['wetlands'] = wetlands37
w_wetlands37.to_csv(join(data_dir, f'w_wetlands37.csv'), index=False)

## -------------------------------------------------------------------------##
## Plot
## -------------------------------------------------------------------------##
if plot_dir is not None:
    emissions = ['Wetlands', 'Livestock',
                ['Coal', 'Oil', 'Gas'],
                ['Wastewater', 'Landfills'],
                ['Termites', 'Seeps', 'BiomassBurn', 'Lakes'],
                ['Rice', 'OtherAnth']]
    titles = ['Wetlands', 'Livestock', 'Coal, Oil, and\nNatural Gas',
              'Wastewater\nand Landfills', 'Other Biogenic\nSources',
              'Other Anthropogenic\nSources']

    # Set colormap
    colormap = fp.cmap_trans('viridis')

    ncategory = len(emissions)
    fig, ax = fp.get_figax(rows=2, cols=math.ceil(ncategory/2), maps=True,
                           lats=emis_correct.lat, lons=emis_correct.lon)
    plt.subplots_adjust(hspace=0.5)
    cax = fp.add_cax(fig, ax, cbar_pad_inches=0.5)
    for i, axis in enumerate(ax.flatten()):
        axis = fp.format_map(axis, lats=emis_correct.lat, lons=emis_correct.lon)
        if type(emissions[i]) == str:
            e = emis_correct['EmisCH4_%s' % emissions[i]].squeeze()
        elif type(emissions[i]) == list:
            e = sum(emis_correct['EmisCH4_%s' % em].squeeze()
                    for em in emissions[i])

        c = e.plot(ax=axis, cmap=colormap, vmin=0, vmax=5,
                   add_colorbar=False)
        cb = fig.colorbar(c, cax=cax, ticks=np.arange(0, 6, 1))
        cb = fp.format_cbar(cb, cbar_title=r'Emissions (Mg km$^2$ a$^{-1}$)')
        axis = fp.add_title(axis, titles[i])

    fp.save_fig(fig, plot_dir, 'prior_emissions_2019')

# Select total emissions
# emis = emis['EmisCH4_Total']

print('The minimum positive emission is',
      np.abs(emis['EmisCH4_Total'].where(emis['EmisCH4_Total'] > 0).min()).values)

## -------------------------------------------------------------------------##
## Generate prior and prior error covariance
## -------------------------------------------------------------------------##
# Relative prior
xa = np.ones(nstate)
xa = xr.DataArray(xa, dims=('nstate'))
xa.to_netcdf(join(data_dir, 'xa.nc'))

# Relative errors
sa = rel_err**2*np.ones(nstate)
sa = xr.DataArray(sa, dims=('nstate'))
sa.to_netcdf(join(data_dir, 'sa.nc'))

# # Absolute prior
# xa_abs = ip.clusters_2d_to_1d(clusters, emis)
# xa_abs = xr.DataArray(xa_abs, dims=('nstate'))
# xa_abs.to_netcdf(join(data_dir, 'xa_abs.nc'))

# Absolute errors
sa_abs = sa*tot_emis['correct']**2
sa_abs.to_netcdf(join(data_dir, 'sa_abs.nc'))

# # Varying errors
# sa_var = 1*tot_emis.mean()/tot_emis
# sa_var[sa_var < 1] = 1
# sa_var[sa_var > 5] = 5
# sa_var = sa_var**2
# sa_var.to_netcdf(join(data_dir, 'sa_var.nc'))

# s_a_vec = 0.5*x_a.mean()/x_a
# s_a_vec[s_a_vec < 0.5] = 0.5
